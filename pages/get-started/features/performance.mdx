# Performance

Tempo's architecture is designed to deliver the throughput, latency, and reliability that payment applications require. From consensus to execution to block structure, every layer is optimized for high-volume financial transactions.

## Simplex consensus: deterministic finality in under one second

Most blockchains use probabilistic finality where block producers race to extend the chain, creating the possibility of chain reorganizations. Bitcoin requires ~6 confirmations (60 minutes). Ethereum requires 12-15 minutes. These are probabilistic guarantees—reorg risks always exist.

Tempo uses the Simplex consensus protocol, which provides cryptographic, single-slot finality through Byzantine Fault Tolerant (BFT) agreement. Validators engage in a structured consensus round for each block. No block is considered final until 2/3+ of validators have explicitly signed it. There are no forks, no orphaned blocks, no reorganizations.

Block times target ~1 second. Once a transaction is in a finalized block, it's cryptographically final—backed by signatures from a supermajority of validators. The network can tolerate up to 1/3 of validators being Byzantine (malicious, compromised, or offline) without compromising safety or liveness.

For payment applications, this enables settlement flows that simply aren't possible on probabilistic-finality chains. Real-time payment systems, instant merchant confirmations, and automated settlement triggers all become practical.

[Read the Simplex specification →](/documentation/consensus)

[Learn more about Simplex consensus →](https://simplex.blog/)

## Reth execution client: native code performance

Tempo's execution layer is built on Reth, a modular Ethereum execution client written in Rust. Running payment operations as Solidity contracts in the EVM creates performance bottlenecks—bytecode interpretation, storage operations via Merkle proofs, and state trie updates all impose overhead.

Reth's modular architecture allows Tempo to implement payment-critical operations as protocol precompiles rather than Solidity contracts. TIP-20 token operations, Stablecoin Exchange orderbook matching, Fee AMM swaps, and transfer policy evaluation all run as native Rust code. Precompiles access state directly without EVM overhead while maintaining deterministic execution across all nodes.

While payment primitives are precompiled for performance, Tempo maintains full EVM compatibility for general application development. Developers can deploy standard Solidity contracts and use existing tooling. The hybrid architecture gives payment operations native performance while preserving Ethereum's developer ecosystem.

[Learn more about Reth →](https://reth.rs/)

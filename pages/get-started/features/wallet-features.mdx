# Wallet Features

Tempo's blockchain includes native features that fundamentally improve the wallet and transaction experience. Rather than requiring external contracts or workarounds, these capabilities are built directly into the protocol.

## Gas fees are payable in any TIP-20 token

Most blockchains have a single native gas token that users must hold to pay transaction fees. If you want to send USDC, you need to also hold ETH (or the chain's native token) just to pay for gas. This creates friction: users need multiple tokens, and they're exposed to price volatility on the gas token.

Tempo has no native gas token. Transaction fees are paid directly in TIP-20 USD stablecoins, and the following protocol determines which token to use for fees:

1. **Transaction-level preference**: Optional `fee_token` field on the transaction
2. **User-level preference**: Default token set by the user on the FeeManager contract
3. **Validator-level preference**: Default token set by the validator

[Learn about fee tokens →](/documentation/transactions/transaction-fee-tokens)

### Fee AMM for automatic token conversion

When users want to pay fees in a different stablecoin than what validators accept, the Fee AMM handles conversion automatically. This precompiled automated market maker swaps between TIP-20 stablecoins atomically within each transaction.

Market makers provide liquidity to the Fee AMM and earn fees from conversions. The protocol ensures users can pay in any supported stablecoin while validators receive their preferred token—without requiring users to manually swap tokens before transacting.

[Learn about the Fee AMM →](/documentation/exchange)

[Learn about providing Fee AMM liquidity →](/documentation/exchange/providing-liquidity)

## Native account abstraction for flexible transactions

Standard Ethereum accounts (EOAs) are limited in fundamental ways. They use sequential nonces, which means you can only process one transaction at a time from an account. They only support ECDSA signatures, requiring users to manage private keys. And they can't batch multiple operations into a single transaction without deploying a smart contract wallet.

Tempo implements a native account abstraction transaction type at the protocol level. Every account automatically delegates to a default account abstraction precompile via EIP-7702, providing smart contract functionality without deployment overhead.

### Fee payer signature field to delegate gas fees

The protocol separates who signs the transaction from who pays the fee. Applications can cover gas costs for their users, creating seamless onboarding without requiring users to acquire gas tokens first.

```typescript
const hash = await client.sendTransaction({
  account: userAccount,
  to: recipientAddress,
  value: amount,
  feePayer: sponsorAccount // Sponsor pays the gas
})
```

This enables "gasless" experiences where applications sponsor fees on behalf of users.

[Learn about fee sponsorship →](/documentation/transactions/fee-sponsorship)

### 2D nonces for non-sequential transactions

Traditional accounts use sequential nonces (0, 1, 2, 3...), forcing transactions to execute in order. Tempo supports parallel nonce spaces, allowing concurrent transaction processing from the same account.

```typescript
// Submit multiple transactions concurrently
const txs = await Promise.all([
  client.sendTransaction({ nonce: [0, 0], ... }), // Nonce space 0, index 0
  client.sendTransaction({ nonce: [1, 0], ... }), // Nonce space 1, index 0
  client.sendTransaction({ nonce: [2, 0], ... })  // Nonce space 2, index 0
])
```

A payment system can submit thousands of transactions simultaneously without waiting for sequential ordering.

[Learn about parallel nonces →](/documentation/accounts#parallel-nonces)

### Alternative signature schemes

Native support for WebAuthn/P256 signatures alongside ECDSA. Users can authenticate with passkeys stored in their device's secure enclave instead of managing private keys.

```typescript
const account = toPasskeyAccount({
  credentialId: '...',
  publicKey: '...'
})

await client.sendTransaction({
  account, // Uses P256 signature
  to: recipientAddress,
  value: amount
})
```

Users authenticate with fingerprint or Face ID, with built-in device sync and recovery.

[Learn about passkey accounts →](/documentation/accounts)

### Batch transactions in calls array

Multiple calls execute atomically within a single transaction. Send payments to 100 recipients, approve a token spend, and execute a swap—all in one transaction that either succeeds completely or fails completely.

```typescript
await client.sendTransaction({
  calls: [
    { to: token, data: transferCalldata },
    { to: anotherToken, data: approveCalldata },
    { to: dexAddress, data: swapCalldata }
  ]
})
```

All operations execute atomically—if any call fails, the entire transaction reverts.

[Learn about batch transactions →](/documentation/transactions/batch-transactions)

### Transaction scheduling with validBefore and validAfter

Transactions specify validity time windows enforced by the protocol. Schedule a payment to execute at a specific time without external automation infrastructure.

```typescript
await client.sendTransaction({
  to: recipientAddress,
  value: amount,
  validAfter: 1704067200,  // Unix timestamp: execute after this time
  validBefore: 1704153600  // Unix timestamp: execute before this time
})
```

Validators will only include the transaction when it becomes valid, enabling "set and forget" scheduled payments.

[Learn about scheduled transactions →](/documentation/transactions/scheduled-transactions)

[Read the account abstraction specification →](/protocol/transactions/account-abstraction)

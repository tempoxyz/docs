import { Callout } from 'vocs/components'

# Account Abstraction Transactions

Tempo introduces a new transaction type to offer the same features as account abstraction, but natively on Tempo. This includes passkey support, gas sponsorship, and scheduled transactions.

## Features

- **Multiple signature types**: secp256k1, P256 (passkeys), and WebAuthn signatures
- **Gas sponsorship**: Built-in fee payer support for gasless transactions
- **Scheduled transactions**: Optional time windows for transaction execution
- **Batch operations**: Execute multiple calls atomically using ERC-7821

## Signature Types

The AA transaction type supports three different signature schemes, automatically detected by signature length:

### secp256k1 (65 bytes)

Standard Ethereum signatures using the secp256k1 curve.

### P256 (130 bytes)

P256 signatures using the secp256r1 curve.

### WebAuthn (Variable length)

P256 sigs with Webauthn support allows using passkeys and  biometric authentication for transaction signing.


## Gas Sponsorship

AA transactions have built-in support for gas sponsorship, allowing applications to pay for their users' transaction fees.

```ts
// User signs the transaction
const userSignature = await wallet.signTransaction({
  to: '0x...',
  value: parseEther('0.1'),
})

// Sponsor signs to pay the fees
const feePayerSignature = await sponsor.signFeePayment(transaction)

// Submit with both signatures
const hash = await client.sendTransaction({
  ...transaction,
  signature: userSignature,
  feePayerSignature: feePayerSignature,
})
```

The fee payer's address is recovered from the `feePayerSignature`, and fees are deducted from the fee payer's balance instead of the transaction sender's balance.

For more details, see [Fee Sponsorship](/documentation/transactions/fee-sponsorship).

## Scheduled Transactions

AA transactions can include optional `validBefore` and `validAfter` timestamps to control when the transaction can be executed.

```ts
// Transaction can only be included after a specific time
const hash = await client.sendTransaction({
  to: '0x...',
  value: parseEther('1'),
  validAfter: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now
  validBefore: Math.floor(Date.now() / 1000) + 7200, // 2 hours from now
})
```

## Transaction Structure

The AA transaction type includes standard EIP-1559 fields plus AA-specific fields:

```typescript
interface AATransaction {
  // Standard fields
  chainId: bigint
  maxPriorityFeePerGas: bigint
  maxFeePerGas: bigint
  gasLimit: bigint
  calls: Call[]  // Batch of calls to execute atomically
  accessList: AccessListItem[]

  // AA-specific fields
  nonceKey: bigint // 256-bit nonce key for parallel execution
  nonce: bigint // 64-bit sequence value

  signature: Bytes

  // Optional fields
  feePayerSignature?: Bytes
  feeToken?: Address
  validBefore?: bigint
  validAfter?: bigint
}
```

## Technical Details

For complete protocol specifications and implementation details, see the [Account Abstraction](/protocol/transactions/aa-transaction) specification.


## Future Features

### Parallelizable Nonces

AA transactions use a 2D nonce system with nonce keys and sequences. This allows sending multiple transactions in parallel without waiting for previous transactions to confirm.

#### How It Works

- **Nonce Key**: An identifier for a parallel transaction stream (256-bit number)
- **Nonce Sequence**: The current value for that key (64-bit number)
- **Protocol Nonce (Key 0)**: The standard sequential nonce, maintained for compatibility

```ts
// Send transactions in parallel using different nonce keys
const tx1 = await client.sendTransaction({
  to: recipient1,
  value: parseEther('1'),
  nonceKey: 1,
  nonceSequence: 0, // First transaction on key 1
})

const tx2 = await client.sendTransaction({
  to: recipient2,
  value: parseEther('1'),
  nonceKey: 2,
  nonceSequence: 0, // First transaction on key 2 (parallel)
})

// Both transactions can be included in the same block
```

<Callout type="info">
The protocol nonce (key 0) works exactly like traditional Ethereum nonces. Using nonce key 0 maintains full backward compatibility with existing tools and workflows.
</Callout>

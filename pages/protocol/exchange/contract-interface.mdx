import { Callout } from 'vocs/components'

# Contract Interface

The Stablecoin Exchange is implemented as a singleton precompiled contract deployed at a fixed address. This page documents the complete Solidity interface, including all functions, events, and data structures.

## Goals and Tradeoffs

The primary goal is to provide optimal pricing for users who are doing cross-stablecoin payments (converting one stablecoin to another), while minimizing chain load from excessive market maker places/cancels or probabilistic MEV.

**Key Design Decisions:**
- Only designed for trading between two same-asset stablecoins
- Only USD-denominated TIP-20 tokens are supported; pairs are created only when both the base token and its quote token are USD.
- Onchain queue of passive orders that use price-time priority, to encourage makers to leave liquidity onchain
- "Flip orders" to make passive liquidity easy, and reduce message volume
- Flips/places delayed until end of block, to prevent backrunning/MEV/JIT strategies
- Passive orders allowed to "cross" (bids can be higher than asks), to minimize complexity and failure cases
- System optimized for normal trading conditions between stable pairs, not for volatile market conditions
- High dust limit ($100) to prevent orders from making swaps too expensive
- No built-in fees for now (will likely handle fees through gas)

## Contract Address

```solidity
address constant STABLECOIN_EXCHANGE = 0xDEc0000000000000000000000000000000000000;
```

The exchange is deployed as a precompiled contract at this fixed address on all Tempo networks.

## Interface Overview

The `IStablecoinExchange` interface provides functions for:
- Executing swaps between stablecoins
- Placing and cancelling limit orders
- Managing balances held on the exchange
- Querying prices and liquidity

## Functions

### Balance Management

#### balanceOf

View a user's balance of a specific token held on the exchange.

```solidity
function balanceOf(
    address user,
    address token
) external view returns (uint128)
```

**Parameters:**
- `user` - The address to query
- `token` - The token address

**Returns:**
- `uint128` - The balance amount

**Usage:**
```solidity
uint128 balance = exchange.balanceOf(msg.sender, USDC_ADDRESS);
```

#### withdraw

Transfer tokens from your exchange balance to your wallet.

```solidity
function withdraw(
    address token,
    uint128 amount
) external
```

**Parameters:**
- `token` - The token address to withdraw
- `amount` - The amount to withdraw

**Usage:**
```solidity
exchange.withdraw(USDC_ADDRESS, 1000e6);
```

### Swap Functions

#### swapExactAmountIn

Execute a swap with an exact input amount, receiving at least a minimum output.

```solidity
function swapExactAmountIn(
    address tokenIn,
    address tokenOut,
    uint128 amountIn,
    uint128 minAmountOut
) external returns (uint128 amountOut)
```

**Parameters:**
- `tokenIn` - Token being sold
- `tokenOut` - Token being bought
- `amountIn` - Exact amount of `tokenIn` to sell
- `minAmountOut` - Minimum acceptable amount of `tokenOut` (slippage protection)

**Returns:**
- `amountOut` - Actual amount of `tokenOut` received

**Reverts:**
- `InsufficientLiquidity` - If order book cannot satisfy `minAmountOut`
- `InvalidPair` - If tokens are not directly paired

**Usage:**
```solidity
uint128 received = exchange.swapExactAmountIn(
    USDC_ADDRESS,
    USDT_ADDRESS,
    1000e6,  // Sell exactly 1000 USDC
    998e6    // Receive at least 998 USDT
);
```

#### swapExactAmountOut

Execute a swap to receive an exact output amount, spending at most a maximum input.

```solidity
function swapExactAmountOut(
    address tokenIn,
    address tokenOut,
    uint128 amountOut,
    uint128 maxAmountIn
) external returns (uint128 amountIn)
```

**Parameters:**
- `tokenIn` - Token being sold
- `tokenOut` - Token being bought
- `amountOut` - Exact amount of `tokenOut` to receive
- `maxAmountIn` - Maximum acceptable amount of `tokenIn` to spend (slippage protection)

**Returns:**
- `amountIn` - Actual amount of `tokenIn` spent

**Reverts:**
- `InsufficientLiquidity` - If order book cannot satisfy `maxAmountIn` constraint
- `InvalidPair` - If tokens are not directly paired

**Usage:**
```solidity
uint128 spent = exchange.swapExactAmountOut(
    USDC_ADDRESS,
    USDT_ADDRESS,
    1000e6,  // Receive exactly 1000 USDT
    1002e6   // Spend at most 1002 USDC
);
```

#### quoteSwapExactAmountIn

View function to simulate a swap with exact input amount.

```solidity
function quoteSwapExactAmountIn(
    address tokenIn,
    address tokenOut,
    uint128 amountIn
) external view returns (uint128 amountOut)
```

**Parameters:**
- `tokenIn` - Token being sold
- `tokenOut` - Token being bought
- `amountIn` - Amount of `tokenIn` to sell

**Returns:**
- `amountOut` - Expected amount of `tokenOut` that would be received

**Usage:**
```solidity
uint128 expectedOut = exchange.quoteSwapExactAmountIn(
    USDC_ADDRESS,
    USDT_ADDRESS,
    1000e6
);
```

<Callout type="note">
  Quote functions are view-only and do not execute trades. They calculate expected prices based on current order book state.
</Callout>

#### quoteSwapExactAmountOut

View function to simulate a swap with exact output amount.

```solidity
function quoteSwapExactAmountOut(
    address tokenIn,
    address tokenOut,
    uint128 amountOut
) external view returns (uint128 amountIn)
```

**Parameters:**
- `tokenIn` - Token being sold
- `tokenOut` - Token being bought
- `amountOut` - Amount of `tokenOut` to receive

**Returns:**
- `amountIn` - Expected amount of `tokenIn` that would be needed

**Usage:**
```solidity
uint128 expectedIn = exchange.quoteSwapExactAmountOut(
    USDC_ADDRESS,
    USDT_ADDRESS,
    1000e6
);
```

### Order Management

#### place

Place a limit order in the order book.

```solidity
function place(
    address token,
    uint128 amount,
    bool isBid,
    int16 tick
) external returns (uint128 orderId)
```

**Parameters:**
- `token` - The token being traded (must trade against its quote token)
- `amount` - Order size denominated in `token`
- `isBid` - `true` for buy order, `false` for sell order
- `tick` - Price tick: `(price - 1) × 10000` where price is in quote token per token

**Returns:**
- `orderId` - Unique identifier for the placed order

**Constraints:**
- Order amount must meet minimum size requirement ($100)
- Tick must be within allowed price band (±2% from peg, i.e., ±200 ticks)
- Token must have sufficient balance on exchange or in wallet

**Usage:**
```solidity
// Place bid to buy 1000 USDC at $0.9990 (tick = -10)
uint128 orderId = exchange.place(
    USDC_ADDRESS,
    1000e6,
    true,   // isBid
    -10     // tick
);
```

<Callout type="warning">
  Orders are queued and added to the book at end of block. They are not immediately visible to other contracts until block settlement.
</Callout>

#### placeFlip

Place a flip order that automatically reverses when filled.

```solidity
function placeFlip(
    address token,
    uint128 amount,
    bool isBid,
    int16 tick,
    int16 flipTick
) external returns (uint128 orderId)
```

**Parameters:**
- All parameters from `place()`, plus:
- `flipTick` - Price tick where order will flip when filled
  - Must be `> tick` if `isBid` is `true`
  - Must be `< tick` if `isBid` is `false`

**Returns:**
- `orderId` - Unique identifier for the placed flip order

**Behavior:**
When a flip order is completely filled:
1. The original order is removed
2. A new flip order is automatically created on the opposite side
3. The new order has `tick = original flipTick` and `flipTick = original tick`
4. This process repeats indefinitely as orders fill

**Usage:**
```solidity
// Place flip order: buy at $0.9990, flip to sell at $1.0010
uint128 orderId = exchange.placeFlip(
    USDC_ADDRESS,
    1000e6,
    true,   // isBid: start as buy order
    -10,    // tick: buy at $0.9990
    10      // flipTick: sell at $1.0010 when filled
);
```

#### cancel

Cancel an existing order and refund the unfilled amount.

```solidity
function cancel(
    uint128 orderId
) external
```

**Parameters:**
- `orderId` - The ID of the order to cancel

**Effects:**
- Removes order from the book immediately
- Refunds unfilled portion to maker's exchange balance
- Only the order maker can cancel their own orders

**Usage:**
```solidity
exchange.cancel(12345);
```

## Events

### OrderPlaced

Emitted when a limit order is placed.

```solidity
event OrderPlaced(
    uint128 indexed orderId,
    address indexed maker,
    address indexed token,
    uint128 amount,
    bool isBid,
    int16 tick
)
```

### FlipOrderPlaced

Emitted when a flip order is placed.

```solidity
event FlipOrderPlaced(
    uint128 indexed orderId,
    address indexed maker,
    address indexed token,
    uint128 amount,
    bool isBid,
    int16 tick,
    int16 flipTick
)
```

### OrderCancelled

Emitted when an order is cancelled.

```solidity
event OrderCancelled(
    uint128 indexed orderId
)
```

### OrderFilled

Emitted when an order is filled (partially or completely).

```solidity
event OrderFilled(
    uint128 indexed orderId,
    address indexed maker,
    address indexed taker,
    uint128 amountFilled,
    bool partialFill
)
```

**Fields:**
- `orderId` - The order that was filled
- `maker` - The address that placed the order
- `taker` - The address that executed against the order
- `amountFilled` - Amount of the order that was filled
- `partialFill` - `true` if order was partially filled, `false` if completely filled

## Data Types

### Tick Representation

Prices are represented as `int16` tick values:

```solidity
int16 tick = (price - 1) * 10000;
```

Where `price` is the token price denominated in its quote token.

**Examples:**
- $0.9990 → tick = -10
- $1.0000 → tick = 0
- $1.0010 → tick = 10

**Constraints:**
- Minimum tick: -200 (price = $0.98)
- Maximum tick: 200 (price = $1.02)
- Tick size: 0.1 basis points (0.001%)

### Order IDs

Order IDs are `uint128` values that uniquely identify each order. They are assigned sequentially by the contract and returned when orders are placed.

### Amounts

All token amounts use `uint128` and are denominated in the token's native decimals (typically 6 for USD stablecoins).

## Error Conditions

Common errors returned by the contract:

- `InsufficientLiquidity` - Not enough orders to satisfy swap constraints
- `InvalidPair` - Tokens are not directly paired for trading
- `InsufficientBalance` - User lacks sufficient balance (wallet + exchange combined)
- `TickOutOfRange` - Tick is outside allowed ±200 range
- `InvalidFlipTick` - Flip tick violates ordering constraint (must be > tick for bids, < tick for asks)
- `OrderTooSmall` - Order size below minimum ($100)
- `UnauthorizedCancel` - Attempting to cancel another user's order
- `OrderNotFound` - Order ID does not exist or already filled/cancelled

import { Callout } from 'vocs/components'

# Execution Semantics

This page describes the detailed execution mechanics of the Stablecoin Exchange, including order matching algorithms, settlement flows, and timing guarantees.

## Overview

The exchange implements a hybrid execution model that separates immediate operations (swaps, cancellations) from deferred operations (new order placement, flip order creation). This design prevents MEV attacks while maintaining efficient price discovery.

## Execution Timeline

### Within-Block Operations

Different operations execute at different points within a block:

1. **Immediate Execution** (during transaction):
   - `swapExactAmountIn()` / `swapExactAmountOut()` - Execute instantly against order book
   - `cancel()` - Remove orders immediately
   - `withdraw()` - Transfer tokens immediately

2. **Queued for End-of-Block**:
   - `place()` - Orders added to pending queue
   - `placeFlip()` - Flip orders added to pending queue
   - Orders remain invisible to smart contracts until processed

3. **End-of-Block Settlement**:
   - Flip orders that were completely filled create new orders
   - Pending orders are added to the book
   - All operations become visible to next block

<Callout type="warning">
  **Important**: Orders placed during a block are not visible to other contracts in that same block. This prevents backrunning and JIT liquidity attacks.
</Callout>

## Take Processing (Immediate Swaps)

When a user executes a swap, the exchange follows this algorithm:

### Step 1: Balance Resolution

```
IF user has sufficient balance on DEX:
    Use DEX balance
ELSE:
    Transfer required tokens from user's wallet
    Credit to user's DEX balance
```

### Step 2: Order Matching

The exchange walks through the order book using price-time priority:

```
current_tick = best_available_tick
amount_remaining = amount_to_fill

WHILE amount_remaining > 0 AND current_tick within limit_price:
    orders_at_tick = get_orders_at_tick(current_tick)

    FOR EACH order IN orders_at_tick (in placement order):
        fill_amount = min(amount_remaining, order.remaining_amount)

        // Fill the order
        order.remaining_amount -= fill_amount
        amount_remaining -= fill_amount

        // Credit maker's DEX balance
        credit_to_dex_balance(order.maker, fill_amount * price)

        // Emit OrderFilled event
        emit OrderFilled(order.id, order.maker, taker, fill_amount, order.remaining_amount > 0)

        IF order.remaining_amount == 0:
            IF order is flip order:
                queue_flip_for_end_of_block(order)
            ELSE:
                remove_order_from_book(order)

        IF amount_remaining == 0:
            BREAK

    current_tick = next_worse_tick()
```

### Step 3: Slippage Check

```
IF swap is exact_amount_in:
    REQUIRE(amount_out >= min_amount_out, "InsufficientLiquidity")
ELSE IF swap is exact_amount_out:
    REQUIRE(amount_in <= max_amount_in, "InsufficientLiquidity")
```

### Step 4: Settlement

```
// Debit taker's balance (already done in Step 1)
// Credit taker with output tokens
transfer_to_wallet(taker, token_out, amount_out)
```

### Gas Costs

Gas consumption for swaps scales with:

- **BASE_TAKE_COST**: Fixed cost for setup and transfers
- **TICK_TAKE_COST × ticks_crossed**: Per price level traversed
- **ORDER_TAKE_COST × orders_touched**: Per order matched against
- **FLIP_COST × flips_triggered**: Per flip order that completely fills

## Queued Operations Handling

### Order Placement Flow

When `place()` or `placeFlip()` is called:

```
1. Validate parameters:
   - Check tick is within allowed range (±200)
   - Check amount meets minimum size ($100)
   - Verify token has valid quote token

2. Debit tokens:
   IF user has sufficient DEX balance:
       Debit from DEX balance
   ELSE:
       Transfer from wallet to exchange
       Debit from DEX balance

3. Add to pending queue:
   pending_orders.push({
       maker: msg.sender,
       token: token,
       amount: amount,
       isBid: isBid,
       tick: tick,
       flipTick: flipTick (if flip order),
       block: current_block
   })

4. Assign and return order ID:
   orderId = next_order_id++
   return orderId
```

<Callout type="note">
  Pending orders are stored in a separate queue and are completely invisible to view functions and other contracts until the block ends.
</Callout>

### Blinding Mechanism

The pending order queue is "blinded" - not accessible through any public interface:

- View functions like `quoteSwapExactAmountIn()` only see orders already in the active book
- Smart contracts cannot detect pending orders in the current block
- This prevents MEV strategies that depend on observing order flow

## End-of-Block Processing

At the end of each block, the exchange processes all queued operations in a specific sequence:

### Processing Sequence

```
FUNCTION processEndOfBlock():
    // Step 1: Process flip orders that filled during the block
    FOR EACH filled_flip_order IN filled_flips_queue:
        new_order = create_flipped_order(filled_flip_order)
        add_to_active_book(new_order, priority=FLIPPED)

    // Step 2: Process pending new orders
    FOR EACH pending_order IN pending_queue (in placement order):
        add_to_active_book(pending_order, priority=NORMAL)

    // Step 3: Clear queues
    filled_flips_queue.clear()
    pending_queue.clear()
```

### Flip Order Creation

When a flip order is completely filled:

```
FUNCTION create_flipped_order(original_order):
    new_order = {
        maker: original_order.maker,
        token: original_order.token,
        amount: original_order.amount,
        isBid: !original_order.isBid,  // Reverse side
        tick: original_order.flipTick,  // Old flip becomes new tick
        flipTick: original_order.tick,  // Old tick becomes new flip
        isFlipOrder: true
    }
    return new_order
```

### Order Priority

Orders added to the book follow strict priority rules:

1. **Price Priority**: Better prices fill first
   - For bids: Higher tick (higher price) is better
   - For asks: Lower tick (lower price) is better

2. **Time Priority** (within same price tick):
   - Orders that flipped in current block come first (in flip order)
   - Then orders placed in current block (in placement order)
   - Then orders from previous blocks (in original placement order)

This ensures:
- Flip orders get priority when they flip (rewarding liquidity providers)
- New orders don't jump ahead of existing orders at same price
- First-in-first-out within each category

## Order Book Data Structures

### Tick Structure

Each tick maintains a FIFO queue of orders:

```
struct Tick {
    int16 tickValue;
    uint128 totalLiquidity;  // Aggregate size for quote functions
    Order[] orders;          // FIFO queue
}
```

### Order Structure

```
struct Order {
    uint128 orderId;
    address maker;
    address token;
    uint128 amount;
    uint128 filledAmount;
    bool isBid;
    int16 tick;
    int16 flipTick;      // 0 if not a flip order
    bool isFlipOrder;
    uint256 blockPlaced;
    uint256 indexInBlock; // Order within block for time priority
}
```

### Order Book Organization

```
OrderBook {
    // Bids: sorted high to low (best bid = highest tick)
    mapping(int16 => Tick) bids;
    int16[] bidTicks;  // Sorted array for traversal

    // Asks: sorted low to high (best ask = lowest tick)
    mapping(int16 => Tick) asks;
    int16[] askTicks;  // Sorted array for traversal

    // Order lookup
    mapping(uint128 => Order) orders;

    // Pending operations
    Order[] pendingOrders;
    Order[] filledFlips;
}
```

## Order Matching Algorithm

### Finding Best Price

```
FUNCTION getBestBid():
    RETURN bidTicks[0]  // Highest tick

FUNCTION getBestAsk():
    RETURN askTicks[0]  // Lowest tick
```

### Walking the Book

For a buy order (swapping tokenIn for tokenOut):

```
current_tick = getBestAsk()
WHILE amount_remaining > 0 AND current_tick <= max_tick:
    tick_orders = asks[current_tick]

    FOR order IN tick_orders.orders:
        fill_order(order, amount_remaining)
        IF amount_remaining == 0:
            RETURN

    current_tick = getNextAsk(current_tick)
```

For a sell order:

```
current_tick = getBestBid()
WHILE amount_remaining > 0 AND current_tick >= min_tick:
    tick_orders = bids[current_tick]

    FOR order IN tick_orders.orders:
        fill_order(order, amount_remaining)
        IF amount_remaining == 0:
            RETURN

    current_tick = getNextBid(current_tick)
```

## Accounting & Settlement

### Balance Tracking

The exchange maintains internal balances for all users:

```
mapping(address => mapping(address => uint128)) balances;
```

### Settlement Flow for Swaps

```
FUNCTION settleSwap(taker, tokenIn, tokenOut, amountIn, amountOut):
    // Debit input token (already done during balance resolution)
    // Credit output token
    balances[taker][tokenOut] += amountOut

    // Transfer output to taker's wallet
    ITIP20(tokenOut).transfer(taker, amountOut)
```

### Settlement Flow for Filled Orders

```
FUNCTION settleFill(order, amountFilled, price):
    // Calculate proceeds in quote token terms
    proceeds = amountFilled * price

    // Credit maker's DEX balance
    IF order.isBid:
        // Maker receives base token
        balances[order.maker][order.token] += amountFilled
    ELSE:
        // Maker receives quote token
        balances[order.maker][quoteToken] += proceeds
```

## Cancellation Mechanics

When `cancel(orderId)` is called:

```
FUNCTION cancel(orderId):
    order = orders[orderId]

    // Verify caller is maker
    REQUIRE(msg.sender == order.maker, "UnauthorizedCancel")

    // Remove from book
    remove_from_tick(order.tick, orderId)

    // Refund unfilled amount to maker's DEX balance
    IF order.isBid:
        // Refund quote token
        refund = order.amount * price - order.filledAmount * price
        balances[order.maker][quoteToken] += refund
    ELSE:
        // Refund base token
        refund = order.amount - order.filledAmount
        balances[order.maker][order.token] += refund

    // Emit event
    emit OrderCancelled(orderId)

    // Delete order
    delete orders[orderId]
```

## Quote Functions

Quote functions simulate swaps without executing them:

```
FUNCTION quoteSwapExactAmountIn(tokenIn, tokenOut, amountIn):
    // Same algorithm as swap, but read-only
    // Walk through ticks and calculate output
    // Use totalLiquidity at each tick to avoid iterating all orders

    amount_remaining = amountIn
    amount_out = 0
    current_tick = best_tick

    WHILE amount_remaining > 0 AND has_liquidity(current_tick):
        tick_liquidity = ticks[current_tick].totalLiquidity
        fill_at_tick = min(amount_remaining, tick_liquidity)

        amount_out += fill_at_tick * tick_price(current_tick)
        amount_remaining -= fill_at_tick

        current_tick = next_tick(current_tick)

    RETURN amount_out
```

The `totalLiquidity` field at each tick allows efficient quoting without iterating every order.

## Order Crossing

Orders are allowed to cross (bids higher than asks):

```
// This is valid:
place(USDC, 1000e6, true, 10)   // Bid at $1.0010
place(USDC, 1000e6, false, -10) // Ask at $0.9990

// Both orders remain in book at their specified prices
```

When a swap executes:
- It fills the best-priced orders first
- Crossed orders don't automatically match
- This simplifies order placement logic and reduces failure cases

## Gas Model

### Cost Components

```
Gas_Swap = BASE_TAKE_COST
         + (TICK_TAKE_COST × ticks_crossed)
         + (ORDER_TAKE_COST × orders_touched)
         + (FLIP_COST × flips_triggered)
         + transfer_costs

Gas_Place = PLACE_COST + transfer_cost

Gas_PlaceFlip = PLACE_FLIP_COST + transfer_cost

Gas_Cancel = CANCEL_COST

Gas_Withdraw = WITHDRAW_COST + transfer_cost
```

### Cost Rationale

- **High place costs**: Prevent spam and encourage meaningful liquidity
- **Low cancel costs**: Allow makers to adjust positions freely
- **Variable swap costs**: Scale with liquidity consumed
- **Future expiring orders**: May offer cheaper placement with automatic cleanup

# Fee AMM

## Overview

The Fee AMM is an enshrined Automated Market Maker that facilitates gas fee payments by converting between stablecoins. It enables users to pay fees in their preferred stablecoin while validators receive fees in their preferred stablecoin.

## Design Principles

The Fee AMM implements a one-way trading system with two distinct swap mechanisms:

### Fee Swaps (Protocol-Only)
- **Direction**: User token → Validator token
- **Rate**: Fixed at 0.9970 (validator token per user token)
- **Execution**: Automatically by protocol at transaction end
- **Settlement**: Batch settlement at block end

### Rebalancing Swaps (Public)
- **Direction**: Validator token → User token
- **Rate**: Fixed at 0.9985 (validator token per user token)
- **Execution**: Anyone can rebalance pools
- **Purpose**: Restore pool balance for future fee swaps

## MEV Mitigation

The system is specifically designed to minimize extractable value:

### No Probabilistic MEV
Fixed swap rates and batch settlement prevent profitable backrunning of fee swaps. There's no incentive to spam transactions hoping for arbitrage opportunities.

### No Sandwich Attacks
Fee swaps execute at fixed rates and settle atomically at block end, eliminating sandwich attack vectors entirely.

### Top-of-Block Auction
The main MEV opportunity from rebalancing occurs as a single race at the top of the next block, rather than creating ongoing probabilistic spam.

## Pool Architecture

Each pair of stablecoins has **two separate pools**, one for each direction:

```
Pool A: userToken → validatorToken (fee swaps)
Pool B: validatorToken → userToken (rebalancing)
```

This design ensures:
- Fee swaps never compete with rebalancing swaps
- Fixed rates can be maintained in both directions
- Liquidity providers face predictable price dynamics

## Core Operations

### 1. Fee Collection
When a transaction pays fees:
1. Protocol deducts fee from user's balance in their preferred token
2. Fee swap is queued with `pendingFeeSwapIn` counter
3. No reserves are updated yet (prevents intra-block MEV)

### 2. Block-End Settlement
At the end of each block:
1. Protocol calls `executePendingFeeSwaps()` for each pool
2. All pending fee swaps settle atomically
3. Reserves are updated to reflect the batch swap
4. Validator receives converted fees in their preferred token

### 3. Rebalancing
Arbitrageurs restore pool balance by:
1. Calling `rebalanceSwap()` at top of next block
2. Trading from validator token back to user token
3. Profiting from the rate differential (0.9985 vs 0.9970)

## Liquidity Requirements

For a transaction to use a particular fee token:

- Pool must have sufficient reserves to support the swap
- Validation happens at transaction inclusion time
- Insufficient liquidity makes the transaction invalid

## Example Flow

```
Block N:
- Alice pays 10 USDC for gas (wants USDC)
- Bob pays 5 USDT for gas (wants USDT)
- Validator prefers USDGLO
- Fee swaps queued: 10 USDC→USDGLO, 5 USDT→USDGLO

Block N End:
- Execute pending: USDC→USDGLO and USDT→USDGLO pools settle
- Validator receives ~9.97 USDGLO and ~4.985 USDGLO

Block N+1 Start:
- Arbitrageur rebalances pools by trading USDGLO back
```

## Integration Points

The Fee AMM integrates with:

- **FeeManager**: Determines which token to use for each transaction
- **Validators**: Specify preferred token via `block.coinbase`
- **Transaction Types**: AATransaction and FeeTokenTransaction support fee token selection

## Specification

For complete technical details including pool structure, swap algorithms, reserve management, and system transactions, see [Fee AMM Spec](https://github.com/tempoxyz/docs/blob/main/specs/FeeAMM.md).

## Related

- [Fees](/protocol/fees/fees) - Fee system and token selection
- [Transactions](/protocol/transactions) - Transaction types supporting fee tokens

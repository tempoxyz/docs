# TIP-403: Policy Registry System

## Abstract

TIP-403 provides a policy registry system that allows TIP-20 tokens to inherit access control and compliance policies. The registry supports two types of policies (whitelist and blacklist) and includes special built-in policies for common use cases. Policies can be shared across multiple tokens, enabling consistent compliance enforcement.


## Motivation

Token issuers often need to implement compliance policies such as KYC/AML requirements, access control, and risk management. Without a standardized system, each token would need to implement its own policy logic, leading to:

- **Code Duplication**: Similar policy logic across multiple tokens
- **Inconsistency**: Different implementations of the same policy type
- **Maintenance Overhead**: Updating policies across multiple tokens
- **Gas Inefficiency**: Storing policy data in each token contract


## Specification

The TIP-403 registry stores policies that TIP-20 tokens check against on any token transfer. Policies are associated with a unique `policyId`, can either be a blacklist or a whitelist policy, and contain a list of addresses. This list of addresses can be updated by the policy `admin`.

Custom policies start with `policyId = 2`. The registry reserves the first two ids for built-in policies: 
1. `policyId = 0` is the `always-reject` policy and rejects all token transfers
2. `policyId = 1` is the `always-allow` policy and allows all token transfers


### Interfaces

#### Contract Types

```solidity
interface ITIP403Registry {
    enum PolicyType {
        WHITELIST,
        BLACKLIST
    }

    struct PolicyData {
        PolicyType policyType;
        address admin;
    }
}
```


#### Policy Creation

```solidity
function createPolicy(
    address admin,
    PolicyType policyType
) public returns (uint64 newPolicyId)
```

Creates a new policy with the specified admin and type. Returns the unique policy ID associated with the created policy.

```solidity
function createPolicyWithAccounts(
    address admin,
    PolicyType policyType,
    address[] memory accounts
) public returns (uint64 newPolicyId)
```

Creates a policy and immediately adds the provided accounts to the policy set. Returns the unique policy ID associated with the created policy.


#### Policy Administration

These policy administrative functions can only be called by the current policy admin.

```solidity
function setPolicyAdmin(uint64 policyId, address admin) external
```

Transfers admin rights to another address. 

```solidity
function modifyPolicyWhitelist(uint64 policyId, address account, bool allowed) external
```

Adds or removes addresses from a whitelist policy. 

```solidity
function modifyPolicyBlacklist(uint64 policyId, address account, bool restricted) external
```

Adds or removes addresses from a blacklist policy. 


#### Viewing Policy State

```solidity
function isAuthorized(uint64 policyId, address user) external view returns (bool)
```

Returns whether the provided user is allowed to transfer tokens under the provided policy ID. 

```solidity
function policyIdCounter() external view returns (uint64)
```

Returns the next policy ID that will be assigned to a newly created policy.

```solidity
function policyData(uint64 policyId) external returns (PolicyType, address)
```

Returns the policy type and admin address of the policy associated with the provided policy ID.


#### Usage with TIP-20 Tokens

TIP-20 tokens store the current TIP403 registry policy ID they adhere to in it's storage. On any token transfer, it performs a TIP-403 policy check. The policy to use for the token can only be set by the admin of the token. 

A quick example is shown below to create and set a policy:

```solidity

address admin = address(this);

// Create policy with registry
uint64 policyId = tip403Registry.createPolicy(admin, PolicyType.WHITELIST);

// Set policy on the token
token.changeTransferPolicyId(policyId);
```


#### Events
```solidity
event PolicyCreated(uint64 indexed policyId, address indexed updater, PolicyType policyType);
event PolicyAdminUpdated(uint64 indexed policyId, address indexed updater, address indexed admin);
event WhitelistUpdated(uint64 indexed policyId, address indexed updater, address indexed account, bool allowed);
event BlacklistUpdated(uint64 indexed policyId, address indexed updater, address indexed account, bool restricted);
```


#### Errors

The contract defines the following custom errors:

```solidity
error Unauthorized();              // Caller is not the policy admin
error IncompatiblePolicyType();    // Wrong policy type for the operation
error PolicyDoesNotExist();        // Policy ID doesn't exist
error ArrayLengthMismatch();       // Array lengths don't match
```


## Example Usage

### Compliance Enforcement

Implement KYC/AML requirements across multiple tokens:

```solidity
// Create a KYC whitelist policy
uint64 kycPolicy = registry.createPolicy(complianceAdmin, PolicyType.WHITELIST);

// Add KYC'd users
registry.modifyPolicyWhitelist(kycPolicy, kycUser1, true);
registry.modifyPolicyWhitelist(kycPolicy, kycUser2, true);

// Apply to multiple tokens
token1.changeTransferPolicyId(kycPolicy);
token2.changeTransferPolicyId(kycPolicy);
```


### Risk Management

Implement blacklists for blocked addresses:

```solidity
// Create a blacklist policy
uint64 blacklistPolicy = registry.createPolicy(riskAdmin, PolicyType.BLACKLIST);

// Add blocked addresses
registry.modifyPolicyBlacklist(blacklistPolicy, blockedAddress1, true);
registry.modifyPolicyBlacklist(blacklistPolicy, blockedAddress2, true);
```


### Emergency Controls

Use special policies for emergency situations:

```solidity
// Emergency stop - block all transfers
token.changeTransferPolicyId(0); // always-reject

// Resume normal operations
token.changeTransferPolicyId(1); // always-allow
```
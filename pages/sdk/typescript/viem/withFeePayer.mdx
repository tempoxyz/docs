# `withFeePayer`

Creates a transport that routes transactions to a fee payer service when a `feePayer` is requested on an action. [Learn more about Fee Sponsorship](/documentation/protocol/transactions/spec-account-abstraction)

## Usage

:::code-group

```ts twoslash [example.ts]
// @noErrors
// [!include ~/snippets/unformatted/withFeePayer-basic.ts:setup]

// [!include ~/snippets/unformatted/withFeePayer-basic.ts:usage]
```

```ts twoslash [viem.config.ts] filename="viem.config.ts"
// [!include ~/snippets/viem.config.ts:setup]
```

:::

### Example Fee Payer Service

Below is an end-to-end example of a client/server fee payer setup. 

See `server.ts` for the server-side implementation with [Bun](https://bun.sh).

:::code-group

```ts twoslash [client.ts]
// @noErrors
import { createClient, http, walletActions } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { tempo } from 'tempo.ts/chains'
import { withFeePayer } from 'tempo.ts/viem'

const credentials = `${process.env['TEMPO_USERNAME']}:${process.env['TEMPO_PASSWORD']}`

const client = createClient({
  account: privateKeyToAccount('0x...'),
  chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),
  transport: withFeePayer(
    http(undefined, {
      fetchOptions: {
        headers: {
          Authorization: `Basic ${btoa(credentials)}`,
        },
      },
    }), 
    // `server.ts` running on `http://localhost:3000` [!code hl]
    http('http://localhost:3000'), // [!code hl]
  ),
}).extend(walletActions)

const hash = await client.sendTransactionSync({
  feePayer: true,
  to: '0x0000000000000000000000000000000000000000',
})
```

```ts twoslash [server.ts]
// @noErrors
import { createClient, http, walletActions } from 'viem'
import { mnemonicToAccount } from 'viem/accounts'
import { RpcRequest, RpcResponse } from 'ox'
import { tempo } from 'tempo.ts/chains'
import { Transaction } from 'tempo.ts/viem'

const credentials = `${process.env['TEMPO_USERNAME']}:${process.env['TEMPO_PASSWORD']}`

const client = createClient({
  account: mnemonicToAccount(
    'test test test test test test test test test test test junk'
  ),
  chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),
  transport: http(undefined, {
    fetchOptions: {
      headers: {
        Authorization: `Basic ${btoa(credentials)}`,
      },
    },
  }),
}).extend(walletActions)

Bun.serve({
  port: 3000,
  async fetch(req) {
    const request = RpcRequest.from(await req.json())
    const serialized = request.params[0] as `0x76${string}`
    
    // Deserialize the sender's signed transaction
    const transaction = Transaction.deserialize(serialized)
    
    // Add fee payer signature
    const serializedTransaction = await client.signTransaction({
      ...transaction,
      feePayer: client.account,
    })

    // Submit to blockchain
    const result = await client.request({
      method: request.method,
      params: [serializedTransaction],
    })

    return Response.json(RpcResponse.from({ result }, { request }))
  }
})
```

:::

## Return Type

```ts
type ReturnType = Transport<'feePayer'>
```

## Parameters

### defaultTransport

- **Type:** `Transport`

The default transport to use for regular (non-sponsored) transactions.

### relayTransport

- **Type:** `Transport`

The relay transport to use for sponsored transactions. This should point to a fee payer service that will sign and submit the transaction with a fee payer signature.

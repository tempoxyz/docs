# `withFeePayer`

Creates a transport that routes transactions to a fee payer service when a `feePayer` is requested on an action. [Learn more about Fee Payers](/protocol/transactions/fee-payers)

## Usage

:::code-group

```ts twoslash [example.ts]
import { createClient, http, walletActions } from 'viem'
import { tempo } from 'tempo.ts/chains'
import { withFeePayer } from 'tempo.ts/viem'
import { privateKeyToAccount } from 'viem/accounts'

const credentials = `${process.env['TEMPO_USERNAME']}:${process.env['TEMPO_PASSWORD']}`

const client = createClient({
  account: privateKeyToAccount(
    '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  ),
  chain: tempo,
  transport: withFeePayer(
    // [!code focus]
    // Transport for regular transactions // [!code focus]
    http(undefined, {
      // [!code focus]
      fetchOptions: {
        // [!code focus]
        headers: {
          // [!code focus]
          Authorization: `Basic ${btoa(credentials)}`, // [!code focus]
        }, // [!code focus]
      }, // [!code focus]
    }), // [!code focus]
    // Transport for sponsored transactions // [!code focus]
    http('https://sponsor.myapp.com'), // [!code focus]
  ), // [!code focus]
}).extend(walletActions) // [!code focus]

// Regular transaction (uses default transport) // [!code focus]
const receipt1 = await client.sendTransactionSync({
  // [!code focus]
  to: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb', // [!code focus]
}) // [!code focus]

// Sponsored transaction (uses feePayer transport) // [!code focus]
const receipt2 = await client.sendTransactionSync({
  // [!code focus]
  feePayer: true, // [!code focus]
  to: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb', // [!code focus]
}) // [!code focus]
```

```ts twoslash [viem.config.ts] filename="viem.config.ts"
// [!include ~/snippets/viem.config.ts:setup]
```

:::

### Example Fee Payer Service

Below is an end-to-end example of a client/server fee payer setup. 

See `server.ts` for the server-side implementation with [Bun](https://bun.sh).

:::code-group

```ts twoslash [client.ts]
import { createTempoClient, withFeePayer } from 'tempo.ts/viem'
import { privateKeyToAccount } from 'viem/accounts'
import { http, walletActions } from 'viem'

const credentials = `${process.env['TEMPO_USERNAME']}:${process.env['TEMPO_PASSWORD']}`

const client = createTempoClient({
  account: privateKeyToAccount('0x...'),
  transport: withFeePayer(
    http(undefined, {
      fetchOptions: {
        headers: {
          Authorization: `Basic ${btoa(credentials)}`,
        },
      },
    }), 
    // `server.ts` running on `http://localhost:3000` [!code hl]
    http('http://localhost:3000'), // [!code hl]
  ),
}).extend(walletActions)

const hash = await client.sendTransactionSync({
  feePayer: true,
  to: '0x0000000000000000000000000000000000000000',
})
```

```ts twoslash [server.ts]
// @noErrors
import { http, walletActions } from 'viem'
import { mnemonicToAccount } from 'viem/accounts'
import { RpcRequest, RpcResponse } from 'ox'
import { createTempoClient, parseTransaction } from 'tempo.ts/viem'

const credentials = `${process.env['TEMPO_USERNAME']}:${process.env['TEMPO_PASSWORD']}`

const client = createTempoClient({
  account: mnemonicToAccount(
    'test test test test test test test test test test test junk'
  ),
  transport: http(undefined, {
    fetchOptions: {
      headers: {
        Authorization: `Basic ${btoa(credentials)}`,
      },
    },
  }),
}).extend(walletActions)

Bun.serve({
  port: 3000,
  async fetch(req) {
    const request = RpcRequest.from(await req.json())
    const serialized = request.params[0] as `0x77${string}`
    
    // Parse the sender's signed transaction
    const transaction = parseTransaction(serialized)
    
    // Add fee payer signature
    const serializedTransaction = await client.signTransaction({
      ...transaction,
      feePayer: client.account,
    })

    // Submit to blockchain
    const result = await client.request({
      method: request.method,
      params: [serializedTransaction],
    })

    return Response.json(RpcResponse.from({ result }, { request }))
  }
})
```

:::

## Return Type

```ts
type ReturnType = Transport<'feePayer'>
```

## Parameters

### defaultTransport

- **Type:** `Transport`

The default transport to use for regular (non-sponsored) transactions.

### relayTransport

- **Type:** `Transport`

The relay transport to use for sponsored transactions. This should point to a fee payer service that will sign and submit the transaction with a fee payer signature.
import * as Demo from '../../../components/guides/Demo.tsx'
import * as Card from "../../../components/Card.tsx"
import LucideShield from '~icons/lucide/shield'
import LucideFileText from '~icons/lucide/file-text'

# Manage Your Stablecoin

Configure your stablecoin's permissions, supply limits, and compliance policies after deployment. This guide covers granting roles to manage token operations, setting supply caps, configuring transfer policies, and controlling token transfers through pause/unpause functionality.

TIP-20 tokens use a role-based access control system that allows you to delegate different administrative functions to different addresses. For detailed information about the role system, see the [TIP-20 specification](/documentation/protocol/tip20/spec#role-based-access-control).


<Demo.Container name="Manage Your Stablecoin" footerVariant="source" src="tempoxyz/tempo-ts/tree/main/examples/mint">
  <Demo.Connect stepNumber={1} />
  <Demo.AddFunds stepNumber={2} />
  <Demo.CreateOrLoadToken stepNumber={3} />
  <Demo.GrantTokenRoles stepNumber={4} roles={['issuer', 'pause', 'unpause', 'burnBlocked']} />
</Demo.Container>

## Steps

::::steps

### Set Supply Cap

Limit the maximum total supply of your token to prevent unlimited inflation.

<Demo.Container name="Set Supply Cap" footerVariant="source" src="tempoxyz/tempo-ts/tree/main/examples/mint">
  <Demo.Connect stepNumber={1} />
  <Demo.AddFunds stepNumber={2} />
  <Demo.CreateOrLoadToken stepNumber={3} />
  <Demo.SetSupplyCap stepNumber={4} last />
</Demo.Container>

:::code-group

```tsx twoslash [SetSupplyCap.tsx]
import React from 'react'
import { Hooks } from 'tempo.ts/wagmi'
import { parseUnits } from 'viem'

// @noErrors
export function SetSupplyCap() {
  const tokenAddress = '0x...' // Your token address

  const { data: metadata, refetch: refetchMetadata } = // [!code hl]
    Hooks.token.useGetMetadata({ token: tokenAddress }) // [!code hl]

  const setSupplyCap = Hooks.token.useSetSupplyCapSync({ // [!code hl]
    mutation: { onSettled: () => refetchMetadata() }, // [!code hl]
  }) // [!code hl]

  const handleSetSupplyCap = () => { // [!code hl]
    setSupplyCap.mutate({ // [!code hl]
      token: tokenAddress, // [!code hl]
      supplyCap: parseUnits('1000', metadata?.decimals || 6), // [!code hl]
      feeToken: '0x20c0000000000000000000000000000000000001', // [!code hl]
    }) // [!code hl]
  } // [!code hl]

  return (
    <button // [!code hl]
      disabled={setSupplyCap.isPending} // [!code hl]
      onClick={handleSetSupplyCap} // [!code hl]
      type="button" // [!code hl]
    > {/* [!code hl] */}
      {setSupplyCap.isPending ? 'Setting...' : 'Set Cap'} {/* [!code hl] */}
    </button> {/* [!code hl] */}
  )
}
```

```tsx twoslash [config.ts] filename="config.ts"
// @noErrors
import { createConfig, http } from 'wagmi'
import { tempo } from 'tempo.ts/chains'
import { webAuthn } from 'tempo.ts/wagmi'

export const config = createConfig({
  chains: [tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })],
  connectors: [webAuthn()],
  transports: {
    [tempo.id]: http(),
  },
})
```

```solidity [Solidity]
TIP20 token = TIP20(0x20c0000000000000000000000000000000000004);

// Set supply cap to 1,000 tokens (USD has 6 decimals)
token.setSupplyCap(1_000_000_000);

// Set supply cap to 1 billion tokens
token.setSupplyCap(1_000_000_000_000_000);

// Remove supply cap (unlimited)
token.setSupplyCap(type(uint256).max);
```

:::

Setting supply caps requires the **`DEFAULT_ADMIN_ROLE`**. The new cap cannot be less than the current total supply.


### Grant Roles to Delegate Permissions

Assign roles to different addresses to delegate specific token management capabilities:

:::code-group

```tsx twoslash [GrantRoles.tsx]
import React from 'react'
import { Hooks } from 'tempo.ts/wagmi'
import { useAccount } from 'wagmi'
import { useQueryClient } from '@tanstack/react-query'

// @noErrors
export function GrantRoles() {
  const { address } = useAccount()
  const queryClient = useQueryClient()
  const tokenAddress = '0x...' // Your token address
  const [grantee, setGrantee] = React.useState<string>('')

  const roles = ['issuer', 'pause', 'unpause'] as const // [!code hl]

  // Check if grantee has all roles // [!code hl]
  const roleChecks = roles.map((role) => // [!code hl]
    Hooks.token.useHasRole({ // [!code hl]
      account: grantee as `0x${string}`, // [!code hl]
      token: tokenAddress, // [!code hl]
      role: role, // [!code hl]
    }), // [!code hl]
  ) // [!code hl]
  const hasAllRoles = roleChecks.every((check) => check.data === true) // [!code hl]

  const grant = Hooks.token.useGrantRolesSync({ // [!code hl]
    mutation: { // [!code hl]
      onSettled() { // [!code hl]
        queryClient.refetchQueries({ queryKey: ['hasRole'] }) // [!code hl]
      }, // [!code hl]
    }, // [!code hl]
  }) // [!code hl]

  const handleGrant = async () => { // [!code hl]
    if (!tokenAddress || !grantee) return // [!code hl]
    await grant.mutate({ // [!code hl]
      token: tokenAddress, // [!code hl]
      roles: roles, // [!code hl]
      to: grantee as `0x${string}`, // [!code hl]
      feeToken: '0x20c0000000000000000000000000000000000001', // [!code hl]
    }) // [!code hl]
  } // [!code hl]

  return (
    <>
      <div>
        <label>Grant roles to address</label>
        <input
          type="text"
          value={grantee}
          onChange={(e) => setGrantee(e.target.value)}
          placeholder="0x..."
        />
      </div>
      <button // [!code hl]
        disabled={!address || hasAllRoles || grant.isPending} // [!code hl]
        onClick={handleGrant} // [!code hl]
        type="button" // [!code hl]
      > {/* [!code hl] */}
        {grant.isPending ? 'Granting...' : 'Grant'} {/* [!code hl] */}
      </button> {/* [!code hl] */}
    </>
  )
}
```

```tsx twoslash [config.ts] filename="config.ts"
// @noErrors
import { createConfig, http } from 'wagmi'
import { tempo } from 'tempo.ts/chains'
import { webAuthn } from 'tempo.ts/wagmi'

export const config = createConfig({
  chains: [tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })],
  connectors: [webAuthn()],
  transports: {
    [tempo.id]: http(),
  },
})
```

```solidity [Solidity]
TIP20 token = TIP20(0x20c0000000000000000000000000000000000004);

// Grant the issuer role to treasury, to mint tokens
address treasuryAddress = 0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef;
token.grantRole(keccak256("ISSUER_ROLE"), treasuryAddress);

// Grant the pause role to security, to pause transfers
address securityAddress = 0xcafecafebabedeadbeefcafebabedeadbeefcafebabe;
token.grantRole(keccak256("PAUSE_ROLE"), securityAddress);
```

:::

### Configure Transfer Policies

Control who can send and receive your stablecoin for compliance and regulatory requirements.

Transfer policies can be:
- **Always allow**: Anyone can send/receive (default)
- **Always reject**: Nobody can send/receive
- **Whitelist**: Only authorized addresses can send/receive
- **Blacklist**: Blocked addresses cannot send/receive

Learn more about configuring transfer policies in the [TIP-403 specification](/documentation/protocol/tip403/spec).

### Pause and Unpause Token Transfers

Temporarily halt all token transfers during emergency situations or maintenance windows.

<Demo.Container name="Pause and Unpause Your Token" footerVariant="source" src="tempoxyz/tempo-ts/tree/main/examples/mint">
  <Demo.Connect stepNumber={1} />
  <Demo.AddFunds stepNumber={2} />
  <Demo.CreateOrLoadToken stepNumber={3} />
  <Demo.GrantTokenRoles stepNumber={4} roles={['pause', 'unpause']} />
  <Demo.PauseUnpauseTransfers stepNumber={5} last />
</Demo.Container>

:::code-group

```tsx twoslash [PauseUnpauseTransfers.tsx]
import React from 'react'
import { Hooks } from 'tempo.ts/wagmi'

// @noErrors
export function PauseUnpauseTransfers() {
  const tokenAddress = '0x...' // Your token address

  const { data: metadata, refetch: refetchMetadata } = // [!code hl]
    Hooks.token.useGetMetadata({ token: tokenAddress }) // [!code hl]

  const pause = Hooks.token.usePauseSync({ // [!code hl]
    mutation: { onSettled: () => refetchMetadata() }, // [!code hl]
  }) // [!code hl]

  const unpause = Hooks.token.useUnpauseSync({ // [!code hl]
    mutation: { onSettled: () => refetchMetadata() }, // [!code hl]
  }) // [!code hl]

  const paused = metadata?.paused || false // [!code hl]

  const handleToggle = () => { // [!code hl]
    if (paused) { // [!code hl]
      unpause.mutate({ // [!code hl]
        token: tokenAddress, // [!code hl]
        feeToken: '0x20c0000000000000000000000000000000000001', // [!code hl]
      }) // [!code hl]
    } else { // [!code hl]
      pause.mutate({ // [!code hl]
        token: tokenAddress, // [!code hl]
        feeToken: '0x20c0000000000000000000000000000000000001', // [!code hl]
      }) // [!code hl]
    } // [!code hl]
  } // [!code hl]

  const isProcessing = pause.isPending || unpause.isPending // [!code hl]

  return (
    <button // [!code hl]
      disabled={isProcessing} // [!code hl]
      onClick={handleToggle} // [!code hl]
      type="button" // [!code hl]
    > {/* [!code hl] */}
      {isProcessing ? 'Processing...' : paused ? 'Unpause' : 'Pause'} {/* [!code hl] */}
    </button> {/* [!code hl] */}
  )
}
```

```tsx twoslash [config.ts] filename="config.ts"
// @noErrors
import { createConfig, http } from 'wagmi'
import { tempo } from 'tempo.ts/chains'
import { webAuthn } from 'tempo.ts/wagmi'

export const config = createConfig({
  chains: [tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })],
  connectors: [webAuthn()],
  transports: {
    [tempo.id]: http(),
  },
})
```

```solidity [Solidity]
TIP20 token = TIP20(0x20c0000000000000000000000000000000000004);

// Pause all transfers
token.pause();

// Later, unpause to resume normal operation
token.unpause();
```

:::

::::

## Recipes

### Using the Issuer Role

The Issuer role grants the ability to mint and burn tokens, controlling your stablecoin's total supply. To learn how to mint new tokens and burn existing tokens, see the [Mint Stablecoins](/guide/issuance/mint-stablecoins) guide.

### Using the Burn Blocked Role

The Burn Blocked role allows compliance officers to burn tokens from blocked or frozen addresses. This is useful for regulatory compliance when you need to remove tokens from addresses that violate terms of service or legal requirements.

## Best Practices

### Role Separation

Use different addresses for different roles to enhance security. For example, assign the issuer role to your treasury address for minting, and the pause role to your security team for emergency controls.

### Event Monitoring

Monitor on-chain events for role changes, mints, burns, and administrative actions to maintain visibility into token operations and detect unauthorized activities.

### Emergency Procedures

Ensure pause and unpause roles are assigned to trusted addresses and that your team has documented procedures for responding to security incidents requiring token transfers to be halted.

## Learning Resources

<Card.Container>
  <Card.Link
    description="Learn about the role-based access control system and all available roles"
    href="/documentation/protocol/tip20/spec#role-based-access-control"
    icon={LucideShield}
    title="Role-Based Access Control"
  />
  <Card.Link
    description="Learn how to configure transfer policies for compliance requirements"
    href="/documentation/protocol/tip403/spec"
    icon={LucideFileText}
    title="Transfer Policies (TIP-403)"
  />
</Card.Container>


import * as Demo from '../../../components/guides/Demo.tsx'
import * as Step from '../../../components/guides/steps'

# Mint Stablecoins

Create new tokens by minting them to a specified address. Minting increases the total supply of your stablecoin.

## Demo

This demo walks though the entire process of minting a token to a recipient. 

<Demo.Container name="Mint Your Token" footerVariant="source" src="tempoxyz/tempo-ts/tree/main/examples/issuance">
  <Step.Connect stepNumber={1} />
  <Step.AddFunds stepNumber={2} />
  <Step.CreateOrLoadToken stepNumber={3} />
  <Step.GrantTokenRoles stepNumber={4} roles={['issuer']} />
  <Step.MintToken stepNumber={5} last />
</Demo.Container>

## Quick Start

Mint tokens using the `mint` function on your TIP-20 token:

:::code-group

```tsx twoslash [MintToken.tsx]
import React from 'react'
import { Hooks } from 'tempo.ts/wagmi'
import { useAccount } from 'wagmi'
import { parseUnits, pad, stringToHex } from 'viem'
import { useQueryClient } from '@tanstack/react-query'

// @noErrors
export function MintToken() {
  const { address } = useAccount()
  const queryClient = useQueryClient()
  const tokenAddress = '0x...' // Your token address
  const [recipient, setRecipient] = React.useState<string>('')
  const [memo, setMemo] = React.useState<string>('')

  const { data: metadata } = Hooks.token.useGetMetadata({ // [!code hl]
    token: tokenAddress, // [!code hl]
  }) // [!code hl]

  const mint = Hooks.token.useMintSync({ // [!code hl]
    mutation: { // [!code hl]
      onSettled() { // [!code hl]
        queryClient.refetchQueries({ queryKey: ['getBalance'] }) // [!code hl]
      }, // [!code hl]
    }, // [!code hl]
  }) // [!code hl]

  const handleMint = () => { // [!code hl]
    if (!tokenAddress || !recipient || !metadata) return // [!code hl]
    mint.mutate({ // [!code hl]
      amount: parseUnits('100', metadata.decimals), // [!code hl]
      to: recipient as `0x${string}`, // [!code hl]
      token: tokenAddress, // [!code hl]
      memo: memo ? pad(stringToHex(memo), { size: 32 }) : undefined, // [!code hl]
      feeToken: '0x20c0000000000000000000000000000000000001', // [!code hl]
    }) // [!code hl]
  } // [!code hl]

  return (
    <>
      <div>
        <label>Recipient address</label>
        <input
          type="text"
          value={recipient}
          onChange={(e) => setRecipient(e.target.value)}
          placeholder="0x..."
        />
      </div>
      <div>
        <label>Memo (optional)</label>
        <input
          type="text"
          value={memo}
          onChange={(e) => setMemo(e.target.value)}
          placeholder="INV-12345"
        />
      </div>
      <button // [!code hl]
        disabled={!address || mint.isPending} // [!code hl]
        onClick={handleMint} // [!code hl]
        type="button" // [!code hl]
      > {/* [!code hl] */}
        {mint.isPending ? 'Minting...' : 'Mint'} {/* [!code hl] */}
      </button> {/* [!code hl] */}
    </>
  )
}
```

```tsx twoslash [config.ts] filename="config.ts"
// @noErrors
import { createConfig, http } from 'wagmi'
import { tempo } from 'tempo.ts/chains'
import { webAuthn } from 'tempo.ts/wagmi'

export const config = createConfig({
  chains: [tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })],
  connectors: [webAuthn()],
  transports: {
    [tempo.id]: http(),
  },
})
```

```solidity [Solidity]
TIP20 token = TIP20(0x20c0000000000000000000000000000000000004);

// Mint 1,000 tokens to the treasury (USD has 6 decimals)
address treasuryAddress = 0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef;
token.mint(treasuryAddress, 1_000_000_000);

// Mint with a memo for tracking
token.mintWithMemo(
  treasuryAddress,
  1_000_000_000,
  keccak256("Q1_2024_TREASURY_ALLOCATION")
);
```

:::

## Requirements

Minting requires the **`ISSUER_ROLE`**. The token must not exceed its supply cap (if set).

## Minting with Memos

Use `mintWithMemo` when you need to:
- Track the purpose of minting (e.g., `"INVESTOR_ALLOCATION_SERIES_A"`)
- Link mints to offchain records (invoice IDs, transaction references)
- Maintain an audit trail for compliance

The memo is emitted in both a `TransferWithMemo` event and the standard `Mint` event.

## Supply Caps

If your token has a supply cap set, any `mint()` or `mintWithMemo()` call that would exceed the cap will revert with `SupplyCapExceeded()`. You must either:
- Burn tokens to reduce total supply below the cap
- Increase the supply cap (requires `DEFAULT_ADMIN_ROLE`)
- Remove the cap entirely by setting it to `type(uint256).max`

## Burning Tokens

<Demo.Container name="Burn Your Token" footerVariant="source" src="tempoxyz/tempo-ts/tree/main/examples/issuance">
  <Step.Connect stepNumber={1} />
  <Step.AddFunds stepNumber={2} />
  <Step.CreateOrLoadToken stepNumber={3} />
  <Step.GrantTokenRoles stepNumber={4} roles={['issuer']} />
  <Step.MintToken stepNumber={5} />
  <Step.BurnToken stepNumber={6} last />
</Demo.Container>

To decrease supply, you can burn tokens from your own balance:

:::code-group

```tsx twoslash [BurnToken.tsx]
import React from 'react'
import { Hooks } from 'tempo.ts/wagmi'
import { useAccount } from 'wagmi'
import { parseUnits, pad, stringToHex } from 'viem'
import { useQueryClient } from '@tanstack/react-query'

// @noErrors
export function BurnToken() {
  const { address } = useAccount()
  const queryClient = useQueryClient()
  const tokenAddress = '0x...' // Your token address
  const [memo, setMemo] = React.useState<string>('')

  const { data: metadata } = Hooks.token.useGetMetadata({ // [!code hl]
    token: tokenAddress, // [!code hl]
  }) // [!code hl]

  const burn = Hooks.token.useBurnSync({ // [!code hl]
    mutation: { // [!code hl]
      onSettled() { // [!code hl]
        queryClient.refetchQueries({ queryKey: ['getBalance'] }) // [!code hl]
      }, // [!code hl]
    }, // [!code hl]
  }) // [!code hl]

  const handleBurn = () => { // [!code hl]
    if (!tokenAddress || !address || !metadata) return // [!code hl]
    burn.mutate({ // [!code hl]
      amount: parseUnits('100', metadata.decimals), // [!code hl]
      token: tokenAddress, // [!code hl]
      memo: memo ? pad(stringToHex(memo), { size: 32 }) : undefined, // [!code hl]
      feeToken: '0x20c0000000000000000000000000000000000001', // [!code hl]
    }) // [!code hl]
  } // [!code hl]

  return (
    <>
      <div>
        <label>Memo (optional)</label>
        <input
          type="text"
          value={memo}
          onChange={(e) => setMemo(e.target.value)}
          placeholder="INV-12345"
        />
      </div>
      <button // [!code hl]
        disabled={!address || burn.isPending} // [!code hl]
        onClick={handleBurn} // [!code hl]
        type="button" // [!code hl]
      > {/* [!code hl] */}
        {burn.isPending ? 'Burning...' : 'Burn'} {/* [!code hl] */}
      </button> {/* [!code hl] */}
    </>
  )
}
```

```tsx twoslash [config.ts] filename="config.ts"
// @noErrors
import { createConfig, http } from 'wagmi'
import { tempo } from 'tempo.ts/chains'
import { webAuthn } from 'tempo.ts/wagmi'

export const config = createConfig({
  chains: [tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })],
  connectors: [webAuthn()],
  transports: {
    [tempo.id]: http(),
  },
})
```

```solidity [Solidity]
TIP20 token = TIP20(0x20c0000000000000000000000000000000000004);

// Burn 100 tokens from your own balance
token.burn(100_000_000);

// Burn with a memo for tracking
token.burnWithMemo(100_000_000, keccak256("REDEMPTION_Q1_2024"));
```

:::

Burning requires the **`ISSUER_ROLE`** and sufficient balance in the caller's account.

## Next Steps

- **[Use your stablecoin for fees](/guide/issuance/use-for-fees)** to enable users to pay fees with your token
- **[Manage your stablecoin](/guide/issuance/manage-stablecoin)** with roles, supply caps, and transfer policies



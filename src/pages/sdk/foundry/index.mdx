---
description: Build, test, and deploy smart contracts on Tempo using the Foundry fork. Access protocol-level features with forge and cast tools.
---

# Foundry for Tempo

Tempo builds on top of [Foundry](https://github.com/foundry-rs/foundry): the leading Ethereum development toolkit, through a custom fork that adds first-class support for Tempo.

This fork extends Foundry with Tempo's [protocol-level features](/protocol/), enabling developers to build, test, and deploy contracts that go [beyond the limits of standard EVM chains](/quickstart/evm-compatibility).

For general information about Foundry, see the [Foundry documentation](https://getfoundry.sh/).

## Get started with Foundry

### Install using `foundryup`

Tempo's Foundry fork is installed through the standard upstream `foundryup` using the `-n tempo` flag, no separate installer is required.

Getting started is very easy:

Install regular `foundryup`:

```bash
curl -L https://foundry.paradigm.xyz | bash
```

Or if you already have `foundryup` installed:

```bash
foundryup --update
```

Next, run:

```bash
foundryup -n tempo
```

It will automatically install the latest `nightly` release of all precompiled binaries: [`forge`](https://getfoundry.sh/forge/overview#forge), [`cast`](https://getfoundry.sh/cast/overview#cast), [`anvil`](https://getfoundry.sh/anvil/overview#anvil), and [`chisel`](https://getfoundry.sh/chisel/overview#chisel).

To install a specific version, replace `<TAG_NAME>` with the desired release tag:

```bash
foundryup -n tempo -i <TAG_NAME>
```

### Verify Installation

```bash
forge -V
```

You should see version information include `-tempo`, indicating you are using the Tempo fork.

```bash
# forge <version>-tempo (<commit> <timestamp>)
```

### Create a new Foundry project

Initialize a new project with Tempo support:

```bash
forge init -n tempo my-project && cd my-project
```

Each new project is configured for Tempo out of the box, with [`tempo-std`](https://github.com/tempoxyz/tempo-std), the Tempo standard library installed, containing helpers for Tempo's protocol-level features.

## Use Foundry for your workflows

All standard Foundry commands are supported out of the box.

### Test & deploy with `forge` locally

```bash
# Build your contracts
forge build

# Run all tests locally
forge test

# Run deployment scripts locally
forge script script/Mail.s.sol
```

### Test & deploy with `forge` on Tempo Testnet

```bash
# Set environment variables
export TEMPO_RPC_URL=https://rpc.moderato.tempo.xyz
export VERIFIER_URL=https://contracts.tempo.xyz

# Optional: create a new keypair and request some testnet tokens from the faucet.
cast wallet new
cast rpc tempo_fundAddress <YOUR_WALLET_ADDRESS> --rpc-url $TEMPO_RPC_URL

# Run all tests on Tempo's testnet
forge test

# Deploy and verify a simple contract
forge create src/Mail.sol:Mail \
  --rpc-url $TEMPO_RPC_URL \
  --interactive \
  --broadcast \
  --verify \
  --constructor-args 0x20c0000000000000000000000000000000000001

# Deploy a simple contract with custom fee token
forge create src/Mail.sol:Mail \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url $TEMPO_RPC_URL \
  --interactive \
  --broadcast \
  --verify \
  --constructor-args 0x20c0000000000000000000000000000000000001

# Set a salt for deterministic contract address derivation
# The salt is passed to TIP20_FACTORY.createToken() which uses it with the sender
# address to compute a deterministic deployment address via getTokenAddress(sender, salt)
export SALT="my-unique-salt"

# Run a deployment script and verify
forge script script/Mail.s.sol \
  --sig "run(string)" $SALT \
  --rpc-url $TEMPO_RPC_URL \
  --interactive \
  --sender <YOUR_WALLET_ADDRESS> \
  --broadcast \
  --verify

# Run a deployment script with custom fee token and verify
forge script script/Mail.s.sol \
  --sig "run(string)" $SALT \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url $TEMPO_RPC_URL \
  --interactive \
  --sender <YOUR_WALLET_ADDRESS> \
  --broadcast \
  --verify

# Batch multiple calls into a single atomic transaction
forge script script/Deploy.s.sol \
  --broadcast --batch \
  --rpc-url $TEMPO_RPC_URL \
  --private-key $PRIVATE_KEY
```

For more verification options including verifying existing contracts and API verification, see [Contract Verification](/quickstart/verify-contracts).

:::warning[Batch Transaction Rules]
- **Atomic execution**: If any call reverts, the entire batch reverts
- **Single CREATE allowed**: At most one contract deployment per batch
- **CREATE must be first**: Deployment must be the first operation
- **Value must be zero**: Since Tempo has no native token, value must be 0
- **Silent failures**: Calling a non-existent function without a fallback succeeds silently
:::

### Interact & debug with `cast`

```bash
# Check that your contract is deployed:
cast code <CONTRACT_ADDRESS> \
  --rpc-url $TEMPO_RPC_URL

# Interact with the contract, retrieving the token address:
cast call <CONTRACT_ADDRESS> "token()" \
  --rpc-url $TEMPO_RPC_URL

# Get the name of an ERC20 token:
cast erc20 name <TOKEN_ADDRESS> \
  --rpc-url $TEMPO_RPC_URL

# Check the ERC20 token balance of your address:
cast erc20 balance <TOKEN_ADDRESS> <YOUR_WALLET_ADDRESS> \
  --rpc-url $TEMPO_RPC_URL

# Transfer some of your ERC20 tokens:
cast erc20 transfer <TOKEN_ADDRESS> <RECEIVER_ADDRESS> <AMOUNT> \
  --rpc-url $TEMPO_RPC_URL \
  --interactive

# Transfer some of your ERC20 tokens with custom fee token:
cast erc20 transfer <TOKEN_ADDRESS> <RECEIVER_ADDRESS> <AMOUNT> \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url $TEMPO_RPC_URL \
  --interactive

# Send a transaction with custom fee token:
cast send <CONTRACT_ADDRESS> <FUNCTION_SIGNATURE> \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url $TEMPO_RPC_URL \
  --interactive

# Replay a transaction by hash:
cast run <TX_HASH> \
  --rpc-url $TEMPO_RPC_URL

# Send a batch transaction with multiple calls:
cast batch-send \
  --call "<CONTRACT_ADDRESS>::increment()" \
  --call "<CONTRACT_ADDRESS>::setNumber(uint256):500" \
  --rpc-url $TEMPO_RPC_URL \
  --private-key $PRIVATE_KEY

# Batch with pre-encoded calldata:
ENCODED=$(cast calldata "setNumber(uint256)" 200)
cast batch-send \
  --call "<CONTRACT_ADDRESS>::$ENCODED" \
  --call "<CONTRACT_ADDRESS>::setNumber(uint256):101" \
  --rpc-url $TEMPO_RPC_URL \
  --private-key $PRIVATE_KEY

# Sponsored transaction (gasless for sender):
# Step 1: Get the fee payer signature hash
FEE_PAYER_HASH=$(cast mktx <CONTRACT_ADDRESS> 'increment()' --rpc-url $TEMPO_RPC_URL --private-key $SENDER_KEY --tempo.print-sponsor-hash)
# Step 2: Sponsor signs the hash
SPONSOR_SIG=$(cast wallet sign --private-key $SPONSOR_KEY "$FEE_PAYER_HASH" --no-hash)
# Step 3: Send with sponsor signature
cast send <CONTRACT_ADDRESS> 'increment()' --rpc-url $TEMPO_RPC_URL --private-key $SENDER_KEY --tempo.sponsor-signature "$SPONSOR_SIG"

# Send with 2D nonce (parallel tx submission):
cast send <CONTRACT_ADDRESS> 'increment()' \
  --rpc-url $TEMPO_RPC_URL \
  --private-key $PRIVATE_KEY \
  --nonce 0 --tempo.nonce-key 1

# Send with expiring nonce (time-bounded tx, max 30s):
VALID_BEFORE=$(($(date +%s) + 25))
cast send <CONTRACT_ADDRESS> 'increment()' \
  --rpc-url $TEMPO_RPC_URL \
  --private-key $PRIVATE_KEY \
  --tempo.expiring-nonce --tempo.valid-before $VALID_BEFORE

# Send with access key (delegated signing):
# First authorize the key via Account Keychain precompile
cast send 0xAAAAAAAA00000000000000000000000000000000 \
  'authorizeKey(address,uint8,uint64,bool,(address,uint256)[])' \
  $ACCESS_KEY_ADDR 0 1893456000 false "[]" \
  --rpc-url $TEMPO_RPC_URL \
  --private-key $ROOT_PRIVATE_KEY
# Then send using the access key
cast send <CONTRACT_ADDRESS> 'increment()' \
  --rpc-url $TEMPO_RPC_URL \
  --access-key $ACCESS_KEY_PRIVATE_KEY \
  --root-account $ROOT_ADDRESS
```

### Local Development with Anvil

Anvil supports Tempo mode for local testing and forking Tempo networks:

```bash
# Start anvil in Tempo mode
anvil --tempo --hardfork t1

# Fork a live Tempo network for local testing
anvil --tempo --fork-url $TEMPO_RPC_URL

# Test transactions on local anvil fork
cast send <CONTRACT_ADDRESS> 'increment()' \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url http://127.0.0.1:8545 \
  --private-key $PRIVATE_KEY

# 2D nonce on anvil fork
cast send <CONTRACT_ADDRESS> 'increment()' \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url http://127.0.0.1:8545 \
  --private-key $PRIVATE_KEY \
  --nonce 0 --tempo.nonce-key 100

# Expiring nonce on anvil fork
cast send <CONTRACT_ADDRESS> 'increment()' \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url http://127.0.0.1:8545 \
  --private-key $PRIVATE_KEY \
  --tempo.expiring-nonce --tempo.valid-before $(($(date +%s) + 25))

# Batch transactions on anvil fork
cast batch-send \
  --tempo.fee-token <FEE_TOKEN_ADDRESS> \
  --rpc-url http://127.0.0.1:8545 \
  --call "<CONTRACT_ADDRESS>::increment()" \
  --call "<CONTRACT_ADDRESS>::increment()" \
  --private-key $PRIVATE_KEY
```

## Tempo-Specific CLI Flags

The following flags are available for `cast` and `forge script` for Tempo-specific features:

| Flag | Description | Example |
|------|-------------|---------|
| `--tempo.fee-token <ADDRESS>` | Specify the TIP-20 token to pay transaction fees | `--tempo.fee-token 0x20c0...0001` |
| `--tempo.nonce-key <KEY>` | 2D nonce key for parallel transaction submission | `--tempo.nonce-key 1` |
| `--tempo.expiring-nonce` | Enable expiring nonce for time-bounded transactions | `--tempo.expiring-nonce` |
| `--tempo.valid-before <TIMESTAMP>` | Unix timestamp before which tx must execute (max 30s from now) | `--tempo.valid-before 1704067200` |
| `--tempo.valid-after <TIMESTAMP>` | Unix timestamp after which tx can execute | `--tempo.valid-after 1704067100` |
| `--tempo.sponsor-signature <SIG>` | Pre-signed sponsor signature for gasless transactions | `--tempo.sponsor-signature 0x...` |
| `--tempo.print-sponsor-hash` | Print fee payer signature hash and exit (for sponsor to sign) | `--tempo.print-sponsor-hash` |

Ledger and Trezor wallets are not yet compatible with any `--tempo.*` option.


